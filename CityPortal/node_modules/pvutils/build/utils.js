"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getUTCDate = getUTCDate;
exports.getParametersValue = getParametersValue;
exports.bufferToHexCodes = bufferToHexCodes;
exports.checkBufferParams = checkBufferParams;
exports.utilFromBase = utilFromBase;
exports.utilToBase = utilToBase;
exports.utilConcatBuf = utilConcatBuf;
exports.utilConcatView = utilConcatView;
exports.utilDecodeTC = utilDecodeTC;
exports.utilEncodeTC = utilEncodeTC;
exports.isEqualBuffer = isEqualBuffer;
exports.padNumber = padNumber;
exports.toBase64 = toBase64;
exports.fromBase64 = fromBase64;
exports.arrayBufferToString = arrayBufferToString;
exports.stringToArrayBuffer = stringToArrayBuffer;
exports.nearestPowerOf2 = nearestPowerOf2;
//**************************************************************************************
/**
 * Making UTC date from local date
 * @param {Date} date Date to convert from
 * @returns {Date}
 */
function getUTCDate(date) {
	return new Date(date.getTime() + date.getTimezoneOffset() * 60000);
}
//**************************************************************************************
/**
 * Get value for input parameters, or set a default value
 * @param {Object} parameters
 * @param {string} name
 * @param defaultValue
 */
function getParametersValue(parameters, name, defaultValue) {
	if (parameters instanceof Object === false) return defaultValue;

	if (name in parameters) return parameters[name];

	return defaultValue;
}
//**************************************************************************************
/**
 * Converts "ArrayBuffer" into a hexdecimal string
 * @param {ArrayBuffer} inputBuffer
 * @param {number} [inputOffset=0]
 * @param {number} [inputLength=inputBuffer.byteLength]
 * @returns {string}
 */
function bufferToHexCodes(inputBuffer) {
	var inputOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	var inputLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputBuffer.byteLength - inputOffset;

	var result = "";

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = new Uint8Array(inputBuffer, inputOffset, inputLength)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var item = _step.value;

			var str = item.toString(16).toUpperCase();
			result = result + (str.length === 1 ? "0" : "") + str;
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return result;
}
//**************************************************************************************
/**
 * Check input "ArrayBuffer" for common functions
 * @param {LocalBaseBlock} baseBlock
 * @param {ArrayBuffer} inputBuffer
 * @param {number} inputOffset
 * @param {number} inputLength
 * @returns {boolean}
 */
function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {
	if (inputBuffer instanceof ArrayBuffer === false) {
		baseBlock.error = "Wrong parameter: inputBuffer must be \"ArrayBuffer\"";
		return false;
	}

	if (inputBuffer.byteLength === 0) {
		baseBlock.error = "Wrong parameter: inputBuffer has zero length";
		return false;
	}

	if (inputOffset < 0) {
		baseBlock.error = "Wrong parameter: inputOffset less than zero";
		return false;
	}

	if (inputLength < 0) {
		baseBlock.error = "Wrong parameter: inputLength less than zero";
		return false;
	}

	if (inputBuffer.byteLength - inputOffset - inputLength < 0) {
		baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";
		return false;
	}

	return true;
}
//**************************************************************************************
/**
 * Convert number from 2^base to 2^10
 * @param {Uint8Array} inputBuffer
 * @param {number} inputBase
 * @returns {number}
 */
function utilFromBase(inputBuffer, inputBase) {
	var result = 0;

	if (inputBuffer.length === 1) return inputBuffer[0];

	for (var i = inputBuffer.length - 1; i >= 0; i--) {
		result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);
	}return result;
}
//**************************************************************************************
/**
 * Convert number from 2^10 to 2^base
 * @param {!number} value The number to convert
 * @param {!number} base The base for 2^base
 * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)
 * @returns {ArrayBuffer}
 */
function utilToBase(value, base) {
	var reserved = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

	var internalReserved = reserved;
	var internalValue = value;

	var result = 0;
	var biggest = Math.pow(2, base);

	for (var i = 1; i < 8; i++) {
		if (value < biggest) {
			var retBuf = void 0;

			if (internalReserved < 0) {
				retBuf = new ArrayBuffer(i);
				result = i;
			} else {
				if (internalReserved < i) return new ArrayBuffer(0);

				retBuf = new ArrayBuffer(internalReserved);

				result = internalReserved;
			}

			var retView = new Uint8Array(retBuf);

			for (var j = i - 1; j >= 0; j--) {
				var basis = Math.pow(2, j * base);

				retView[result - j - 1] = Math.floor(internalValue / basis);
				internalValue -= retView[result - j - 1] * basis;
			}

			return retBuf;
		}

		biggest *= Math.pow(2, base);
	}

	return new ArrayBuffer(0);
}
//**************************************************************************************
/**
 * Concatenate two ArrayBuffers
 * @param {...ArrayBuffer} buffers Set of ArrayBuffer
 */
function utilConcatBuf() {
	//region Initial variables
	var outputLength = 0;
	var prevLength = 0;
	//endregion

	//region Calculate output length

	for (var _len = arguments.length, buffers = Array(_len), _key = 0; _key < _len; _key++) {
		buffers[_key] = arguments[_key];
	}

	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = buffers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var buffer = _step2.value;

			outputLength += buffer.byteLength;
		} //endregion
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	var retBuf = new ArrayBuffer(outputLength);
	var retView = new Uint8Array(retBuf);

	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = buffers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var _buffer = _step3.value;

			retView.set(new Uint8Array(_buffer), prevLength);
			prevLength += _buffer.byteLength;
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}

	return retBuf;
}
//**************************************************************************************
/**
 * Concatenate two Uint8Array
 * @param {...Uint8Array} views Set of Uint8Array
 */
function utilConcatView() {
	//region Initial variables
	var outputLength = 0;
	var prevLength = 0;
	//endregion

	//region Calculate output length

	for (var _len2 = arguments.length, views = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		views[_key2] = arguments[_key2];
	}

	var _iteratorNormalCompletion4 = true;
	var _didIteratorError4 = false;
	var _iteratorError4 = undefined;

	try {
		for (var _iterator4 = views[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
			var view = _step4.value;

			outputLength += view.length;
		} //endregion
	} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion4 && _iterator4.return) {
				_iterator4.return();
			}
		} finally {
			if (_didIteratorError4) {
				throw _iteratorError4;
			}
		}
	}

	var retBuf = new ArrayBuffer(outputLength);
	var retView = new Uint8Array(retBuf);

	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = views[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var _view = _step5.value;

			retView.set(_view, prevLength);
			prevLength += _view.length;
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5.return) {
				_iterator5.return();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}

	return retView;
}
//**************************************************************************************
/**
 * Decoding of "two complement" values
 * The function must be called in scope of instance of "hexBlock" class ("valueHex" and "warnings" properties must be present)
 * @returns {number}
 */
function utilDecodeTC() {
	var buf = new Uint8Array(this.valueHex);

	if (this.valueHex.byteLength >= 2) {
		//noinspection JSBitwiseOperatorUsage
		var condition1 = buf[0] === 0xFF && buf[1] & 0x80;
		var condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;

		if (condition1 || condition2) this.warnings.push("Needlessly long format");
	}

	//region Create big part of the integer
	var bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
	var bigIntView = new Uint8Array(bigIntBuffer);
	for (var i = 0; i < this.valueHex.byteLength; i++) {
		bigIntView[i] = 0;
	}bigIntView[0] = buf[0] & 0x80; // mask only the biggest bit

	var bigInt = utilFromBase(bigIntView, 8);
	//endregion

	//region Create small part of the integer
	var smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);
	var smallIntView = new Uint8Array(smallIntBuffer);
	for (var j = 0; j < this.valueHex.byteLength; j++) {
		smallIntView[j] = buf[j];
	}smallIntView[0] &= 0x7F; // mask biggest bit

	var smallInt = utilFromBase(smallIntView, 8);
	//endregion

	return smallInt - bigInt;
}
//**************************************************************************************
/**
 * Encode integer value to "two complement" format
 * @param {number} value Value to encode
 * @returns {ArrayBuffer}
 */
function utilEncodeTC(value) {
	var modValue = value < 0 ? value * -1 : value;
	var bigInt = 128;

	for (var i = 1; i < 8; i++) {
		if (modValue <= bigInt) {
			if (value < 0) {
				var smallInt = bigInt - modValue;

				var _retBuf = utilToBase(smallInt, 8, i);
				var _retView = new Uint8Array(_retBuf);

				_retView[0] |= 0x80;

				return _retBuf;
			}

			var retBuf = utilToBase(modValue, 8, i);
			var retView = new Uint8Array(retBuf);

			//noinspection JSBitwiseOperatorUsage
			if (retView[0] & 0x80) {
				//noinspection JSCheckFunctionSignatures
				var tempBuf = retBuf.slice(0);
				var tempView = new Uint8Array(tempBuf);

				retBuf = new ArrayBuffer(retBuf.byteLength + 1);
				retView = new Uint8Array(retBuf);

				for (var k = 0; k < tempBuf.byteLength; k++) {
					retView[k + 1] = tempView[k];
				}retView[0] = 0x00;
			}

			return retBuf;
		}

		bigInt *= Math.pow(2, 8);
	}

	return new ArrayBuffer(0);
}
//**************************************************************************************
/**
 * Compare two array buffers
 * @param {!ArrayBuffer} inputBuffer1
 * @param {!ArrayBuffer} inputBuffer2
 * @returns {boolean}
 */
function isEqualBuffer(inputBuffer1, inputBuffer2) {
	if (inputBuffer1.byteLength !== inputBuffer2.byteLength) return false;

	var view1 = new Uint8Array(inputBuffer1);
	var view2 = new Uint8Array(inputBuffer2);

	for (var i = 0; i < view1.length; i++) {
		if (view1[i] !== view2[i]) return false;
	}

	return true;
}
//**************************************************************************************
/**
 * Pad input number with leade "0" if needed
 * @returns {string}
 * @param {number} inputNumber
 * @param {number} fullLength
 */
function padNumber(inputNumber, fullLength) {
	var str = inputNumber.toString(10);

	if (fullLength < str.length) return "";

	var dif = fullLength - str.length;

	var padding = new Array(dif);
	for (var i = 0; i < dif; i++) {
		padding[i] = "0";
	}var paddingString = padding.join("");

	return paddingString.concat(str);
}
//**************************************************************************************
var base64Template = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var base64UrlTemplate = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";
//**************************************************************************************
/**
 * Encode string into BASE64 (or "base64url")
 * @param {string} input
 * @param {boolean} useUrlTemplate If "true" then output would be encoded using "base64url"
 * @param {boolean} skipPadding Skip BASE-64 padding or not
 * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not
 * @returns {string}
 */
function toBase64(input) {
	var useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	var skipPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	var skipLeadingZeros = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

	var i = 0;

	var flag1 = 0;
	var flag2 = 0;

	var output = "";

	var template = useUrlTemplate ? base64UrlTemplate : base64Template;

	if (skipLeadingZeros) {
		var nonZeroPosition = 0;

		for (var _i = 0; _i < input.length; _i++) {
			if (input.charCodeAt(_i) !== 0) {
				nonZeroPosition = _i;
				break;
			}
		}

		input = input.slice(nonZeroPosition);
	}

	while (i < input.length) {
		var chr1 = input.charCodeAt(i++);
		if (i >= input.length) flag1 = 1;
		var chr2 = input.charCodeAt(i++);
		if (i >= input.length) flag2 = 1;
		var chr3 = input.charCodeAt(i++);

		var enc1 = chr1 >> 2;
		var enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;
		var enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;
		var enc4 = chr3 & 0x3F;

		if (flag1 === 1) enc3 = enc4 = 64;else {
			if (flag2 === 1) enc4 = 64;
		}

		if (skipPadding) {
			if (enc3 === 64) output += "" + template.charAt(enc1) + template.charAt(enc2);else {
				if (enc4 === 64) output += "" + template.charAt(enc1) + template.charAt(enc2) + template.charAt(enc3);else output += "" + template.charAt(enc1) + template.charAt(enc2) + template.charAt(enc3) + template.charAt(enc4);
			}
		} else output += "" + template.charAt(enc1) + template.charAt(enc2) + template.charAt(enc3) + template.charAt(enc4);
	}

	return output;
}
//**************************************************************************************
/**
 * Decode string from BASE64 (or "base64url")
 * @param {string} input
 * @param {boolean} [useUrlTemplate=false] If "true" then output would be encoded using "base64url"
 * @param {boolean} [cutTailZeros=false] If "true" then cut tailing zeroz from function result
 * @returns {string}
 */
function fromBase64(input) {
	var useUrlTemplate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	var cutTailZeros = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var template = useUrlTemplate ? base64UrlTemplate : base64Template;

	//region Aux functions
	function indexof(toSearch) {
		for (var _i2 = 0; _i2 < 64; _i2++) {
			if (template.charAt(_i2) === toSearch) return _i2;
		}

		return 64;
	}

	function test(incoming) {
		return incoming === 64 ? 0x00 : incoming;
	}
	//endregion

	var i = 0;

	var output = "";

	while (i < input.length) {
		var enc1 = indexof(input.charAt(i++));
		var enc2 = i >= input.length ? 0x00 : indexof(input.charAt(i++));
		var enc3 = i >= input.length ? 0x00 : indexof(input.charAt(i++));
		var enc4 = i >= input.length ? 0x00 : indexof(input.charAt(i++));

		var chr1 = test(enc1) << 2 | test(enc2) >> 4;
		var chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;
		var chr3 = (test(enc3) & 0x03) << 6 | test(enc4);

		output += String.fromCharCode(chr1);

		if (enc3 !== 64) output += String.fromCharCode(chr2);

		if (enc4 !== 64) output += String.fromCharCode(chr3);
	}

	if (cutTailZeros) {
		var outputLength = output.length;
		var nonZeroStart = -1;

		for (var _i3 = outputLength - 1; _i3 >= 0; _i3--) {
			if (output.charCodeAt(_i3) !== 0) {
				nonZeroStart = _i3;
				break;
			}
		}

		if (nonZeroStart !== -1) output = output.slice(0, nonZeroStart + 1);else output = "";
	}

	return output;
}
//**************************************************************************************
function arrayBufferToString(buffer) {
	var resultString = "";
	var view = new Uint8Array(buffer);

	var _iteratorNormalCompletion6 = true;
	var _didIteratorError6 = false;
	var _iteratorError6 = undefined;

	try {
		for (var _iterator6 = view[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
			var element = _step6.value;

			resultString = resultString + String.fromCharCode(element);
		}
	} catch (err) {
		_didIteratorError6 = true;
		_iteratorError6 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion6 && _iterator6.return) {
				_iterator6.return();
			}
		} finally {
			if (_didIteratorError6) {
				throw _iteratorError6;
			}
		}
	}

	return resultString;
}
//**************************************************************************************
function stringToArrayBuffer(str) {
	var stringLength = str.length;

	var resultBuffer = new ArrayBuffer(stringLength);
	var resultView = new Uint8Array(resultBuffer);

	for (var i = 0; i < stringLength; i++) {
		resultView[i] = str.charCodeAt(i);
	}return resultBuffer;
}
//**************************************************************************************
var log2 = Math.log(2);
//**************************************************************************************
/**
 * Get nearest to input length power of 2
 * @param {number} length Current length of existing array
 * @returns {number}
 */
function nearestPowerOf2(length) {
	var base = Math.log(length) / log2;

	var floor = Math.floor(base);
	var round = Math.round(base);

	return floor === round ? floor : round;
}
//**************************************************************************************
//# sourceMappingURL=utils.js.map