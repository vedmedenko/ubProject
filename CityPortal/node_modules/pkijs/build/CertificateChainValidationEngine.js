"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _pvutils = require("pvutils");

var _common = require("./common.js");

var _CertificateRevocationList = require("./CertificateRevocationList.js");

var _CertificateRevocationList2 = _interopRequireDefault(_CertificateRevocationList);

var _Certificate = require("./Certificate.js");

var _Certificate2 = _interopRequireDefault(_Certificate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//**************************************************************************************
var CertificateChainValidationEngine = function () {
	//**********************************************************************************
	/**
  * Constructor for CertificateChainValidationEngine class
  * @param {Object} [parameters={}]
  * @property {Object} [schema] asn1js parsed value
  */
	function CertificateChainValidationEngine() {
		var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, CertificateChainValidationEngine);

		//region Internal properties of the object
		/**
   * @type {Array.<Certificate>}
   * @description Array of pre-defined trusted (by user) certificates
   */
		this.trustedCerts = (0, _pvutils.getParametersValue)(parameters, "trustedCerts", this.defaultValues("trustedCerts"));
		/**
   * @type {Array.<Certificate>}
   * @description Array with certificate chain. Could be only one end-user certificate in there!
   */
		this.certs = (0, _pvutils.getParametersValue)(parameters, "certs", this.defaultValues("certs"));
		/**
   * @type {Array.<CertificateRevocationList>}
   * @description Array of all CRLs for all certificates from certificate chain
   */
		this.crls = (0, _pvutils.getParametersValue)(parameters, "crls", this.defaultValues("crls"));
		/**
   * @type {Array}
   * @description Array of all OCSP responses
   */
		this.ocsps = (0, _pvutils.getParametersValue)(parameters, "ocsps", this.defaultValues("ocsps"));
		/**
   * @type {Date}
   * @description The date at which the check would be
   */
		this.checkDate = (0, _pvutils.getParametersValue)(parameters, "checkDate", this.defaultValues("checkDate"));
		/**
   * @type {Function}
   * @description The date at which the check would be
   */
		this.findOrigin = (0, _pvutils.getParametersValue)(parameters, "findOrigin", this.defaultValues("findOrigin"));
		/**
   * @type {Function}
   * @description The date at which the check would be
   */
		this.findIssuer = (0, _pvutils.getParametersValue)(parameters, "findIssuer", this.defaultValues("findIssuer"));
		//endregion
	}
	//**********************************************************************************


	_createClass(CertificateChainValidationEngine, [{
		key: "defaultFindOrigin",
		value: function defaultFindOrigin(certificate, validationEngine) {
			//region Firstly encode TBS for certificate
			if (certificate.tbs.byteLength === 0) certificate.tbs = certificate.encodeTBS();
			//endregion

			//region Search in Intermediate Certificates
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = validationEngine.certs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var localCert = _step.value;

					//region Firstly encode TBS for certificate
					if (localCert.tbs.byteLength === 0) localCert.tbs = localCert.encodeTBS();
					//endregion

					if ((0, _pvutils.isEqualBuffer)(certificate.tbs, localCert.tbs)) return "Intermediate Certificates";
				}
				//endregion

				//region Search in Trusted Certificates
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = validationEngine.trustedCerts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var trustedCert = _step2.value;

					//region Firstly encode TBS for certificate
					if (trustedCert.tbs.byteLength === 0) trustedCert.tbs = trustedCert.encodeTBS();
					//endregion

					if ((0, _pvutils.isEqualBuffer)(certificate.tbs, trustedCert.tbs)) return "Trusted Certificates";
				}
				//endregion
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			return "Unknown";
		}
		//**********************************************************************************

	}, {
		key: "defaultFindIssuer",
		value: function () {
			var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(certificate, validationEngine) {
				var result, keyIdentifier, authorityCertIssuer, authorityCertSerialNumber, verificationResult, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, extension, checkCertificate, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, trustedCert, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, intermediateCert, i, _verificationResult;

				return regeneratorRuntime.wrap(function _callee$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {
							case 0:
								checkCertificate = function checkCertificate(possibleIssuer) {
									//region Firstly search for appropriate extensions
									if (keyIdentifier !== null) {
										if ("extensions" in possibleIssuer) {
											var extensionFound = false;

											var _iteratorNormalCompletion4 = true;
											var _didIteratorError4 = false;
											var _iteratorError4 = undefined;

											try {
												for (var _iterator4 = possibleIssuer.extensions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
													var _extension = _step4.value;

													if (_extension.extnID === "2.5.29.14") // SubjectKeyIdentifier
														{
															extensionFound = true;

															if ((0, _pvutils.isEqualBuffer)(_extension.parsedValue.valueBlock.valueHex, keyIdentifier.valueBlock.valueHex)) result.push(possibleIssuer);

															break;
														}
												}
											} catch (err) {
												_didIteratorError4 = true;
												_iteratorError4 = err;
											} finally {
												try {
													if (!_iteratorNormalCompletion4 && _iterator4.return) {
														_iterator4.return();
													}
												} finally {
													if (_didIteratorError4) {
														throw _iteratorError4;
													}
												}
											}

											if (extensionFound) return;
										}
									}
									//endregion

									//region Now search for authorityCertSerialNumber
									var authorityCertSerialNumberEqual = false;

									if (authorityCertSerialNumber !== null) authorityCertSerialNumberEqual = possibleIssuer.serialNumber.isEqual(authorityCertSerialNumber);
									//endregion

									//region And at least search for Issuer data
									if (authorityCertIssuer !== null) {
										if (possibleIssuer.subject.isEqual(authorityCertIssuer)) {
											if (authorityCertSerialNumberEqual) result.push(possibleIssuer);
										}
									} else {
										if (certificate.issuer.isEqual(possibleIssuer.subject)) result.push(possibleIssuer);
									}
									//endregion
								};

								//region Initial variables
								result = [];
								keyIdentifier = null;
								authorityCertIssuer = null;
								authorityCertSerialNumber = null;
								//endregion

								//region Speed-up searching in case of self-signed certificates

								if (!certificate.subject.isEqual(certificate.issuer)) {
									_context.next = 16;
									break;
								}

								_context.prev = 6;
								_context.next = 9;
								return certificate.verify();

							case 9:
								verificationResult = _context.sent;

								if (!(verificationResult === true)) {
									_context.next = 12;
									break;
								}

								return _context.abrupt("return", [certificate]);

							case 12:
								_context.next = 16;
								break;

							case 14:
								_context.prev = 14;
								_context.t0 = _context["catch"](6);

							case 16:
								if (!("extensions" in certificate)) {
									_context.next = 44;
									break;
								}

								_iteratorNormalCompletion3 = true;
								_didIteratorError3 = false;
								_iteratorError3 = undefined;
								_context.prev = 20;
								_iterator3 = certificate.extensions[Symbol.iterator]();

							case 22:
								if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
									_context.next = 30;
									break;
								}

								extension = _step3.value;

								if (!(extension.extnID === "2.5.29.35")) {
									_context.next = 27;
									break;
								}

								if ("keyIdentifier" in extension.parsedValue) keyIdentifier = extension.parsedValue.keyIdentifier;else {
									if ("authorityCertIssuer" in extension.parsedValue) authorityCertIssuer = extension.parsedValue.authorityCertIssuer;

									if ("authorityCertSerialNumber" in extension.parsedValue) authorityCertSerialNumber = extension.parsedValue.authorityCertSerialNumber;
								}

								return _context.abrupt("break", 30);

							case 27:
								_iteratorNormalCompletion3 = true;
								_context.next = 22;
								break;

							case 30:
								_context.next = 36;
								break;

							case 32:
								_context.prev = 32;
								_context.t1 = _context["catch"](20);
								_didIteratorError3 = true;
								_iteratorError3 = _context.t1;

							case 36:
								_context.prev = 36;
								_context.prev = 37;

								if (!_iteratorNormalCompletion3 && _iterator3.return) {
									_iterator3.return();
								}

							case 39:
								_context.prev = 39;

								if (!_didIteratorError3) {
									_context.next = 42;
									break;
								}

								throw _iteratorError3;

							case 42:
								return _context.finish(39);

							case 43:
								return _context.finish(36);

							case 44:
								//endregion

								//region Search in Trusted Certificates
								_iteratorNormalCompletion5 = true;
								_didIteratorError5 = false;
								_iteratorError5 = undefined;
								_context.prev = 47;
								for (_iterator5 = validationEngine.trustedCerts[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
									trustedCert = _step5.value;

									checkCertificate(trustedCert);
								} //endregion

								//region Search in Intermediate Certificates
								_context.next = 55;
								break;

							case 51:
								_context.prev = 51;
								_context.t2 = _context["catch"](47);
								_didIteratorError5 = true;
								_iteratorError5 = _context.t2;

							case 55:
								_context.prev = 55;
								_context.prev = 56;

								if (!_iteratorNormalCompletion5 && _iterator5.return) {
									_iterator5.return();
								}

							case 58:
								_context.prev = 58;

								if (!_didIteratorError5) {
									_context.next = 61;
									break;
								}

								throw _iteratorError5;

							case 61:
								return _context.finish(58);

							case 62:
								return _context.finish(55);

							case 63:
								_iteratorNormalCompletion6 = true;
								_didIteratorError6 = false;
								_iteratorError6 = undefined;
								_context.prev = 66;
								for (_iterator6 = validationEngine.certs[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
									intermediateCert = _step6.value;

									checkCertificate(intermediateCert);
								} //endregion

								//region Now perform certificate verification checking
								_context.next = 74;
								break;

							case 70:
								_context.prev = 70;
								_context.t3 = _context["catch"](66);
								_didIteratorError6 = true;
								_iteratorError6 = _context.t3;

							case 74:
								_context.prev = 74;
								_context.prev = 75;

								if (!_iteratorNormalCompletion6 && _iterator6.return) {
									_iterator6.return();
								}

							case 77:
								_context.prev = 77;

								if (!_didIteratorError6) {
									_context.next = 80;
									break;
								}

								throw _iteratorError6;

							case 80:
								return _context.finish(77);

							case 81:
								return _context.finish(74);

							case 82:
								i = 0;

							case 83:
								if (!(i < result.length)) {
									_context.next = 97;
									break;
								}

								_context.prev = 84;
								_context.next = 87;
								return certificate.verify(result[i]);

							case 87:
								_verificationResult = _context.sent;

								if (_verificationResult === false) result.splice(i, 1);
								_context.next = 94;
								break;

							case 91:
								_context.prev = 91;
								_context.t4 = _context["catch"](84);

								result.splice(i, 1); // Something wrong, remove the certificate

							case 94:
								i++;
								_context.next = 83;
								break;

							case 97:
								return _context.abrupt("return", result);

							case 98:
							case "end":
								return _context.stop();
						}
					}
				}, _callee, this, [[6, 14], [20, 32, 36, 44], [37,, 39, 43], [47, 51, 55, 63], [56,, 58, 62], [66, 70, 74, 82], [75,, 77, 81], [84, 91]]);
			}));

			function defaultFindIssuer(_x2, _x3) {
				return _ref.apply(this, arguments);
			}

			return defaultFindIssuer;
		}()
		//**********************************************************************************
		/**
   * Return default values for all class members
   * @param {string} memberName String name for a class member
   */

	}, {
		key: "defaultValues",
		value: function defaultValues(memberName) {
			switch (memberName) {
				case "trustedCerts":
					return [];
				case "certs":
					return [];
				case "crls":
					return [];
				case "ocsps":
					return [];
				case "checkDate":
					return new Date();
				case "findOrigin":
					return this.defaultFindOrigin;
				case "findIssuer":
					return this.defaultFindIssuer;
				default:
					throw new Error("Invalid member name for CertificateChainValidationEngine class: " + memberName);
			}
		}
		//**********************************************************************************

	}, {
		key: "sort",
		value: function () {
			var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
				//endregion

				//region Building certificate path
				var buildPath = function () {
					var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(certificate) {
						var result, checkUnique, findIssuerResult, i, buildPathResult, j, copy;
						return regeneratorRuntime.wrap(function _callee2$(_context2) {
							while (1) {
								switch (_context2.prev = _context2.next) {
									case 0:
										checkUnique = function checkUnique(array) {
											var unique = true;

											for (var i = 0; i < array.length; i++) {
												for (var j = 0; j < array.length; j++) {
													if (j === i) continue;

													if (array[i] === array[j]) {
														unique = false;
														break;
													}
												}

												if (!unique) break;
											}

											return unique;
										};

										result = [];

										//region Aux function checking array for unique elements

										_context2.next = 4;
										return _this.findIssuer(certificate, _this);

									case 4:
										findIssuerResult = _context2.sent;

										if (!(findIssuerResult.length === 0)) {
											_context2.next = 7;
											break;
										}

										throw new Error("No valid certificate paths found");

									case 7:
										i = 0;

									case 8:
										if (!(i < findIssuerResult.length)) {
											_context2.next = 19;
											break;
										}

										if (!(0, _pvutils.isEqualBuffer)(findIssuerResult[i].tbs, certificate.tbs)) {
											_context2.next = 12;
											break;
										}

										result.push([findIssuerResult[i]]);
										return _context2.abrupt("continue", 16);

									case 12:
										_context2.next = 14;
										return buildPath(findIssuerResult[i]);

									case 14:
										buildPathResult = _context2.sent;


										for (j = 0; j < buildPathResult.length; j++) {
											copy = buildPathResult[j].slice();

											copy.splice(0, 0, findIssuerResult[i]);

											if (checkUnique(copy)) result.push(copy);else result.push(buildPathResult[j]);
										}

									case 16:
										i++;
										_context2.next = 8;
										break;

									case 19:
										return _context2.abrupt("return", result);

									case 20:
									case "end":
										return _context2.stop();
								}
							}
						}, _callee2, this);
					}));

					return function buildPath(_x4) {
						return _ref3.apply(this, arguments);
					};
				}();
				//endregion

				//region Find CRL for specific certificate


				var findCRL = function () {
					var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(certificate) {
						var issuerCertificates, crls, crlsAndCertificates, i, j, _result;

						return regeneratorRuntime.wrap(function _callee3$(_context3) {
							while (1) {
								switch (_context3.prev = _context3.next) {
									case 0:
										//region Initial variables
										issuerCertificates = [];
										crls = [];
										crlsAndCertificates = [];
										//endregion

										//region Find all possible CRL issuers

										issuerCertificates.push.apply(issuerCertificates, _toConsumableArray(localCerts.filter(function (element) {
											return certificate.issuer.isEqual(element.subject);
										})));

										if (!(issuerCertificates.length === 0)) {
											_context3.next = 6;
											break;
										}

										return _context3.abrupt("return", {
											status: 1,
											statusMessage: "No certificate's issuers"
										});

									case 6:
										//endregion

										//region Find all CRLs for crtificate's issuer
										crls.push.apply(crls, _toConsumableArray(_this.crls.filter(function (element) {
											return element.issuer.isEqual(certificate.issuer);
										})));

										if (!(crls.length === 0)) {
											_context3.next = 9;
											break;
										}

										return _context3.abrupt("return", {
											status: 1,
											statusMessage: "No CRLs for specific certificate issuer"
										});

									case 9:
										i = 0;

									case 10:
										if (!(i < crls.length)) {
											_context3.next = 32;
											break;
										}

										if (!(crls[i].nextUpdate.value < _this.checkDate)) {
											_context3.next = 13;
											break;
										}

										return _context3.abrupt("continue", 29);

									case 13:
										j = 0;

									case 14:
										if (!(j < issuerCertificates.length)) {
											_context3.next = 29;
											break;
										}

										_context3.prev = 15;
										_context3.next = 18;
										return crls[i].verify({ issuerCertificate: issuerCertificates[j] });

									case 18:
										_result = _context3.sent;

										if (!_result) {
											_context3.next = 22;
											break;
										}

										crlsAndCertificates.push({
											crl: crls[i],
											certificate: issuerCertificates[j]
										});

										return _context3.abrupt("break", 29);

									case 22:
										_context3.next = 26;
										break;

									case 24:
										_context3.prev = 24;
										_context3.t0 = _context3["catch"](15);

									case 26:
										j++;
										_context3.next = 14;
										break;

									case 29:
										i++;
										_context3.next = 10;
										break;

									case 32:
										if (!crlsAndCertificates.length) {
											_context3.next = 34;
											break;
										}

										return _context3.abrupt("return", {
											status: 0,
											statusMessage: "",
											result: crlsAndCertificates
										});

									case 34:
										return _context3.abrupt("return", {
											status: 1,
											statusMessage: "No valid CRLs found"
										});

									case 35:
									case "end":
										return _context3.stop();
								}
							}
						}, _callee3, this, [[15, 24]]);
					}));

					return function findCRL(_x5) {
						return _ref4.apply(this, arguments);
					};
				}();
				//endregion

				//region Find OCSP for specific certificate


				var findOCSP = function () {
					var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(certificate, issuerCertificate) {
						var hashAlgorithm, i, _result2;

						return regeneratorRuntime.wrap(function _callee4$(_context4) {
							while (1) {
								switch (_context4.prev = _context4.next) {
									case 0:
										//region Get hash algorithm from certificate
										hashAlgorithm = (0, _common.getAlgorithmByOID)(certificate.signatureAlgorithm.algorithmId);

										if (!("name" in hashAlgorithm === false)) {
											_context4.next = 3;
											break;
										}

										return _context4.abrupt("return", 1);

									case 3:
										if (!("hash" in hashAlgorithm === false)) {
											_context4.next = 5;
											break;
										}

										return _context4.abrupt("return", 1);

									case 5:
										i = 0;

									case 6:
										if (!(i < _this.ocsps.length)) {
											_context4.next = 17;
											break;
										}

										_context4.next = 9;
										return _this.ocsps[i].getCertificateStatus(certificate, issuerCertificate);

									case 9:
										_result2 = _context4.sent;

										if (!_result2.isForCertificate) {
											_context4.next = 14;
											break;
										}

										if (!(_result2.status === 0)) {
											_context4.next = 13;
											break;
										}

										return _context4.abrupt("return", 0);

									case 13:
										return _context4.abrupt("return", 1);

									case 14:
										i++;
										_context4.next = 6;
										break;

									case 17:
										return _context4.abrupt("return", 2);

									case 18:
									case "end":
										return _context4.stop();
								}
							}
						}, _callee4, this);
					}));

					return function findOCSP(_x6, _x7) {
						return _ref5.apply(this, arguments);
					};
				}();
				//endregion

				//region Check for certificate to be CA


				var checkForCA = function () {
					var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(certificate) {
						var needToCheckCRL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
						var isCA, mustBeCA, keyUsagePresent, cRLSign, j, view;
						return regeneratorRuntime.wrap(function _callee5$(_context5) {
							while (1) {
								switch (_context5.prev = _context5.next) {
									case 0:
										//region Initial variables
										isCA = false;
										mustBeCA = false;
										keyUsagePresent = false;
										cRLSign = false;
										//endregion

										if (!("extensions" in certificate)) {
											_context5.next = 20;
											break;
										}

										j = 0;

									case 6:
										if (!(j < certificate.extensions.length)) {
											_context5.next = 14;
											break;
										}

										if (!(certificate.extensions[j].critical === true && "parsedValue" in certificate.extensions[j] === false)) {
											_context5.next = 9;
											break;
										}

										return _context5.abrupt("return", {
											result: false,
											resultCode: 6,
											resultMessage: "Unable to parse critical certificate extension: " + certificate.extensions[j].extnID
										});

									case 9:

										if (certificate.extensions[j].extnID === "2.5.29.15") // KeyUsage
											{
												keyUsagePresent = true;

												view = new Uint8Array(certificate.extensions[j].parsedValue.valueBlock.valueHex);


												if ((view[0] & 0x04) === 0x04) // Set flag "keyCertSign"
													mustBeCA = true;

												if ((view[0] & 0x02) === 0x02) // Set flag "cRLSign"
													cRLSign = true;
											}

										if (certificate.extensions[j].extnID === "2.5.29.19") // BasicConstraints
											{
												if ("cA" in certificate.extensions[j].parsedValue) {
													if (certificate.extensions[j].parsedValue.cA === true) isCA = true;
												}
											}

									case 11:
										j++;
										_context5.next = 6;
										break;

									case 14:
										if (!(mustBeCA === true && isCA === false)) {
											_context5.next = 16;
											break;
										}

										return _context5.abrupt("return", {
											result: false,
											resultCode: 3,
											resultMessage: "Unable to build certificate chain - using \"keyCertSign\" flag set without BasicConstaints"
										});

									case 16:
										if (!(keyUsagePresent === true && isCA === true && mustBeCA === false)) {
											_context5.next = 18;
											break;
										}

										return _context5.abrupt("return", {
											result: false,
											resultCode: 4,
											resultMessage: "Unable to build certificate chain - \"keyCertSign\" flag was not set"
										});

									case 18:
										if (!(isCA === true && keyUsagePresent === true && needToCheckCRL && cRLSign === false)) {
											_context5.next = 20;
											break;
										}

										return _context5.abrupt("return", {
											result: false,
											resultCode: 5,
											resultMessage: "Unable to build certificate chain - intermediate certificate must have \"cRLSign\" key usage flag"
										});

									case 20:
										if (!(isCA === false)) {
											_context5.next = 22;
											break;
										}

										return _context5.abrupt("return", {
											result: false,
											resultCode: 7,
											resultMessage: "Unable to build certificate chain - more than one possible end-user certificate"
										});

									case 22:
										return _context5.abrupt("return", {
											result: true,
											resultCode: 0,
											resultMessage: ""
										});

									case 23:
									case "end":
										return _context5.stop();
								}
							}
						}, _callee5, this);
					}));

					return function checkForCA(_x9) {
						return _ref6.apply(this, arguments);
					};
				}();
				//endregion

				//region Basic check for certificate path


				var basicCheck = function () {
					var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(path, checkDate) {
						var i, _i, _i2, ocspResult, crlResult, j, isCertificateRevoked, isCertificateCA, _i3, _result3;

						return regeneratorRuntime.wrap(function _callee6$(_context6) {
							while (1) {
								switch (_context6.prev = _context6.next) {
									case 0:
										i = 0;

									case 1:
										if (!(i < path.length)) {
											_context6.next = 7;
											break;
										}

										if (!(path[i].notBefore.value > checkDate || path[i].notAfter.value < checkDate)) {
											_context6.next = 4;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 8,
											resultMessage: "Certificate validity period is out of checking date"
										});

									case 4:
										i++;
										_context6.next = 1;
										break;

									case 7:
										if (!(path.length < 2)) {
											_context6.next = 9;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 9,
											resultMessage: "Too short certificate path"
										});

									case 9:
										_i = path.length - 2;

									case 10:
										if (!(_i >= 0)) {
											_context6.next = 17;
											break;
										}

										if (!(path[_i].issuer.isEqual(path[_i].subject) === false)) {
											_context6.next = 14;
											break;
										}

										if (!(path[_i].issuer.isEqual(path[_i + 1].subject) === false)) {
											_context6.next = 14;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 10,
											resultMessage: "Incorrect name chaining"
										});

									case 14:
										_i--;
										_context6.next = 10;
										break;

									case 17:
										if (!(_this.crls.length !== 0 || _this.ocsps.length !== 0)) {
											_context6.next = 58;
											break;
										}

										_i2 = 0;

									case 19:
										if (!(_i2 < path.length - 2)) {
											_context6.next = 58;
											break;
										}

										//region Initial variables
										ocspResult = void 0;
										crlResult = void 0;
										//endregion

										//region Check OCSPs first

										if (!(_this.ocsps.length !== 0)) {
											_context6.next = 32;
											break;
										}

										_context6.next = 25;
										return findOCSP(path[_i2], path[_i2 + 1]);

									case 25:
										ocspResult = _context6.sent;
										_context6.t0 = ocspResult;
										_context6.next = _context6.t0 === 0 ? 29 : _context6.t0 === 1 ? 30 : _context6.t0 === 2 ? 31 : 32;
										break;

									case 29:
										return _context6.abrupt("continue", 55);

									case 30:
										return _context6.abrupt("return", {
											result: false,
											resultCode: 12,
											resultMessage: "One of certificates was revoked via OCSP response"
										});

									case 31:
										return _context6.abrupt("break", 32);

									case 32:
										if (!(_this.crls.length !== 0)) {
											_context6.next = 53;
											break;
										}

										_context6.next = 35;
										return findCRL(path[_i2]);

									case 35:
										crlResult = _context6.sent;

										if (!crlResult.status) {
											_context6.next = 38;
											break;
										}

										throw {
											result: false,
											resultCode: 11,
											resultMessage: "No revocation values found for one of certificates: " + crlResult.statusMessage
										};

									case 38:
										j = 0;

									case 39:
										if (!(j < crlResult.result.length)) {
											_context6.next = 51;
											break;
										}

										//region Check that the CRL issuer certificate have not been revoked
										isCertificateRevoked = crlResult.result[j].crl.isCertificateRevoked(path[_i2]);

										if (!isCertificateRevoked) {
											_context6.next = 43;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 12,
											resultMessage: "One of certificates had been revoked"
										});

									case 43:
										_context6.next = 45;
										return checkForCA(crlResult.result[j].certificate, true);

									case 45:
										isCertificateCA = _context6.sent;

										if (!(isCertificateCA.result === false)) {
											_context6.next = 48;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 13,
											resultMessage: "CRL issuer certificate is not a CA certificate or does not have crlSign flag"
										});

									case 48:
										j++;
										_context6.next = 39;
										break;

									case 51:
										_context6.next = 55;
										break;

									case 53:
										if (!(ocspResult === 2)) {
											_context6.next = 55;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 11,
											resultMessage: "No revocation values found for one of certificates"
										});

									case 55:
										_i2++;
										_context6.next = 19;
										break;

									case 58:
										_i3 = 1;

									case 59:
										if (!(_i3 < path.length)) {
											_context6.next = 68;
											break;
										}

										_context6.next = 62;
										return checkForCA(path[_i3]);

									case 62:
										_result3 = _context6.sent;

										if (!(_result3.result === false)) {
											_context6.next = 65;
											break;
										}

										return _context6.abrupt("return", {
											result: false,
											resultCode: 14,
											resultMessage: "One of intermediate certificates is not a CA certificate"
										});

									case 65:
										_i3++;
										_context6.next = 59;
										break;

									case 68:
										return _context6.abrupt("return", {
											result: true
										});

									case 69:
									case "end":
										return _context6.stop();
								}
							}
						}, _callee6, this);
					}));

					return function basicCheck(_x10, _x11) {
						return _ref7.apply(this, arguments);
					};
				}();
				//endregion

				//region Do main work
				//region Initialize "localCerts" by value of "_this.certs" + "_this.trustedCerts" arrays


				var localCerts, _this, i, j, result, certificatePath, _i4, found, _j, _certificate, k, shortestLength, shortestIndex, _i5, _i6;

				return regeneratorRuntime.wrap(function _callee7$(_context7) {
					while (1) {
						switch (_context7.prev = _context7.next) {
							case 0:
								//region Initial variables
								localCerts = [];
								_this = this;
								localCerts.push.apply(localCerts, _toConsumableArray(_this.trustedCerts));
								localCerts.push.apply(localCerts, _toConsumableArray(_this.certs));
								//endregion

								//region Check all certificates for been unique
								i = 0;

							case 5:
								if (!(i < localCerts.length)) {
									_context7.next = 20;
									break;
								}

								j = 0;

							case 7:
								if (!(j < localCerts.length)) {
									_context7.next = 17;
									break;
								}

								if (!(i === j)) {
									_context7.next = 10;
									break;
								}

								return _context7.abrupt("continue", 14);

							case 10:
								if (!(0, _pvutils.isEqualBuffer)(localCerts[i].tbs, localCerts[j].tbs)) {
									_context7.next = 14;
									break;
								}

								localCerts.splice(j, 1);
								i = 0;
								return _context7.abrupt("break", 17);

							case 14:
								j++;
								_context7.next = 7;
								break;

							case 17:
								i++;
								_context7.next = 5;
								break;

							case 20:
								//endregion

								//region Initial variables
								result = void 0;
								certificatePath = [localCerts[localCerts.length - 1]]; // The "end entity" certificate must be the least in "certs" array
								//endregion

								//region Build path for "end entity" certificate

								_context7.next = 24;
								return buildPath(localCerts[localCerts.length - 1]);

							case 24:
								result = _context7.sent;

								if (!(result.length === 0)) {
									_context7.next = 27;
									break;
								}

								return _context7.abrupt("return", {
									result: false,
									resultCode: 60,
									resultMessage: "Unable to find certificate path"
								});

							case 27:
								_i4 = 0;

							case 28:
								if (!(_i4 < result.length)) {
									_context7.next = 50;
									break;
								}

								found = false;
								_j = 0;

							case 31:
								if (!(_j < result[_i4].length)) {
									_context7.next = 46;
									break;
								}

								_certificate = result[_i4][_j];
								k = 0;

							case 34:
								if (!(k < _this.trustedCerts.length)) {
									_context7.next = 41;
									break;
								}

								if (!(0, _pvutils.isEqualBuffer)(_certificate.tbs, _this.trustedCerts[k].tbs)) {
									_context7.next = 38;
									break;
								}

								found = true;
								return _context7.abrupt("break", 41);

							case 38:
								k++;
								_context7.next = 34;
								break;

							case 41:
								if (!found) {
									_context7.next = 43;
									break;
								}

								return _context7.abrupt("break", 46);

							case 43:
								_j++;
								_context7.next = 31;
								break;

							case 46:

								if (!found) {
									result.splice(_i4, 1);
									_i4 = 0;
								}

							case 47:
								_i4++;
								_context7.next = 28;
								break;

							case 50:
								if (!(result.length === 0)) {
									_context7.next = 52;
									break;
								}

								throw {
									result: false,
									resultCode: 97,
									resultMessage: "No valid certificate paths found"
								};

							case 52:
								//endregion

								//region Find shortest certificate path (for the moment it is the only criteria)
								shortestLength = result[0].length;
								shortestIndex = 0;


								for (_i5 = 0; _i5 < result.length; _i5++) {
									if (result[_i5].length < shortestLength) {
										shortestLength = result[_i5].length;
										shortestIndex = _i5;
									}
								}
								//endregion

								//region Create certificate path for basic check
								for (_i6 = 0; _i6 < result[shortestIndex].length; _i6++) {
									certificatePath.push(result[shortestIndex][_i6]);
								} //endregion

								//region Perform basic checking for all certificates in the path
								_context7.next = 58;
								return basicCheck(certificatePath, _this.checkDate);

							case 58:
								result = _context7.sent;

								if (!(result.result === false)) {
									_context7.next = 61;
									break;
								}

								throw result;

							case 61:
								return _context7.abrupt("return", certificatePath);

							case 62:
							case "end":
								return _context7.stop();
						}
					}
				}, _callee7, this);
			}));

			function sort() {
				return _ref2.apply(this, arguments);
			}

			return sort;
		}()
		//**********************************************************************************
		/**
   * Major verification function for certificate chain.
   * @param {{initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms}} [parameters]
   * @returns {Promise}
   */

	}, {
		key: "verify",
		value: function () {
			var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
				var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

				var compareDNSName, compareRFC822Name, compareUniformResourceIdentifier, compareIPAddress, compareDirectoryName, initialPolicySet, initialExplicitPolicy, initialPolicyMappingInhibit, initialInhibitPolicy, initialPermittedSubtreesSet, initialExcludedSubtreesSet, initialRequiredNameForms, explicitPolicyIndicator, policyMappingInhibitIndicator, inhibitAnyPolicyIndicator, pendingConstraints, explicitPolicyPending, policyMappingInhibitPending, inhibitAnyPolicyPending, permittedSubtrees, excludedSubtrees, requiredNameForms, pathDepth, allPolicies, policiesAndCerts, anyPolicyArray, ii, policyMappings, certPolicies, explicitPolicyStart, i, j, s, k, policyIndex, _s, certArray, _policyIndex, searchAnyPolicy, _i7, _k, issuerDomainPolicyIndex, subjectDomainPolicyIndex, n, _j2, m, _i8, _j3, authConstrPolicies, _i9, found, _j4, anyPolicyFound, _k2, userConstrPolicies, _i10, _j5, policyResult, _i18, subjectAltNames, certPermittedSubtrees, certExcludedSubtrees, _j7, formFound, _j8, _k3, constrGroups, _j9, p, groupPermitted, valueExists, group, _j10, _k4, _k5, _k6, _k7, _k8, excluded, _j11, _k9, _k10, _k11, _k12, _k13;

				return regeneratorRuntime.wrap(function _callee8$(_context8) {
					while (1) {
						switch (_context8.prev = _context8.next) {
							case 0:
								_context8.prev = 0;

								//endregion
								//endregion

								//region Work with name constraints
								//region Auxiliary functions for name constraints checking
								compareDNSName = function compareDNSName(name, constraint) {
									/// <summary>Compare two dNSName values</summary>
									/// <param name="name" type="String">DNS from name</param>
									/// <param name="constraint" type="String">Constraint for DNS from name</param>
									/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>

									//region Make a "string preparation" for both name and constrain
									var namePrepared = (0, _common.stringPrep)(name);
									var constraintPrepared = (0, _common.stringPrep)(constraint);
									//endregion

									//region Make a "splitted" versions of "constraint" and "name"
									var nameSplitted = namePrepared.split(".");
									var constraintSplitted = constraintPrepared.split(".");
									//endregion

									//region Length calculation and additional check
									var nameLen = nameSplitted.length;
									var constrLen = constraintSplitted.length;

									if (nameLen === 0 || constrLen === 0 || nameLen < constrLen) return false;
									//endregion

									//region Check that no part of "name" has zero length
									for (var _i11 = 0; _i11 < nameLen; _i11++) {
										if (nameSplitted[_i11].length === 0) return false;
									}
									//endregion

									//region Check that no part of "constraint" has zero length
									for (var _i12 = 0; _i12 < constrLen; _i12++) {
										if (constraintSplitted[_i12].length === 0) {
											if (_i12 === 0) {
												if (constrLen === 1) return false;

												continue;
											}

											return false;
										}
									}
									//endregion

									//region Check that "name" has a tail as "constraint"

									for (var _i13 = 0; _i13 < constrLen; _i13++) {
										if (constraintSplitted[constrLen - 1 - _i13].length === 0) continue;

										if (nameSplitted[nameLen - 1 - _i13].localeCompare(constraintSplitted[constrLen - 1 - _i13]) !== 0) return false;
									}
									//endregion

									return true;
								};

								compareRFC822Name = function compareRFC822Name(name, constraint) {
									/// <summary>Compare two rfc822Name values</summary>
									/// <param name="name" type="String">E-mail address from name</param>
									/// <param name="constraint" type="String">Constraint for e-mail address from name</param>
									/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>

									//region Make a "string preparation" for both name and constrain
									var namePrepared = (0, _common.stringPrep)(name);
									var constraintPrepared = (0, _common.stringPrep)(constraint);
									//endregion

									//region Make a "splitted" versions of "constraint" and "name"
									var nameSplitted = namePrepared.split("@");
									var constraintSplitted = constraintPrepared.split("@");
									//endregion

									//region Splitted array length checking
									if (nameSplitted.length === 0 || constraintSplitted.length === 0 || nameSplitted.length < constraintSplitted.length) return false;
									//endregion

									if (constraintSplitted.length === 1) {
										var _result4 = compareDNSName(nameSplitted[1], constraintSplitted[0]);

										if (_result4) {
											//region Make a "splitted" versions of domain name from "constraint" and "name"
											var ns = nameSplitted[1].split(".");
											var cs = constraintSplitted[0].split(".");
											//endregion

											if (cs[0].length === 0) return true;

											return ns.length === cs.length;
										}

										return false;
									}

									return namePrepared.localeCompare(constraintPrepared) === 0;
								};

								compareUniformResourceIdentifier = function compareUniformResourceIdentifier(name, constraint) {
									/// <summary>Compare two uniformResourceIdentifier values</summary>
									/// <param name="name" type="String">uniformResourceIdentifier from name</param>
									/// <param name="constraint" type="String">Constraint for uniformResourceIdentifier from name</param>
									/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>

									//region Make a "string preparation" for both name and constrain
									var namePrepared = (0, _common.stringPrep)(name);
									var constraintPrepared = (0, _common.stringPrep)(constraint);
									//endregion

									//region Find out a major URI part to compare with
									var ns = namePrepared.split("/");
									var cs = constraintPrepared.split("/");

									if (cs.length > 1) // Malformed constraint
										return false;

									if (ns.length > 1) // Full URI string
										{
											for (var _i14 = 0; _i14 < ns.length; _i14++) {
												if (ns[_i14].length > 0 && ns[_i14].charAt(ns[_i14].length - 1) !== ":") {
													var nsPort = ns[_i14].split(":");
													namePrepared = nsPort[0];
													break;
												}
											}
										}
									//endregion

									var result = compareDNSName(namePrepared, constraintPrepared);

									if (result) {
										//region Make a "splitted" versions of "constraint" and "name"
										var nameSplitted = namePrepared.split(".");
										var constraintSplitted = constraintPrepared.split(".");
										//endregion

										if (constraintSplitted[0].length === 0) return true;

										return nameSplitted.length === constraintSplitted.length;
									}

									return false;
								};

								compareIPAddress = function compareIPAddress(name, constraint) {
									/// <summary>Compare two iPAddress values</summary>
									/// <param name="name" type="in_window.org.pkijs.asn1.OCTETSTRING">iPAddress from name</param>
									/// <param name="constraint" type="in_window.org.pkijs.asn1.OCTETSTRING">Constraint for iPAddress from name</param>
									/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>

									//region Common variables
									var nameView = new Uint8Array(name.valueBlock.valueHex);
									var constraintView = new Uint8Array(constraint.valueBlock.valueHex);
									//endregion

									//region Work with IPv4 addresses
									if (nameView.length === 4 && constraintView.length === 8) {
										for (var _i15 = 0; _i15 < 4; _i15++) {
											if ((nameView[_i15] ^ constraintView[_i15]) & constraintView[_i15 + 4]) return false;
										}

										return true;
									}
									//endregion

									//region Work with IPv6 addresses
									if (nameView.length === 16 && constraintView.length === 32) {
										for (var _i16 = 0; _i16 < 16; _i16++) {
											if ((nameView[_i16] ^ constraintView[_i16]) & constraintView[_i16 + 16]) return false;
										}

										return true;
									}
									//endregion

									return false;
								};

								compareDirectoryName = function compareDirectoryName(name, constraint) {
									/// <summary>Compare two directoryName values</summary>
									/// <param name="name" type="in_window.org.pkijs.simpl.RDN">directoryName from name</param>
									/// <param name="constraint" type="in_window.org.pkijs.simpl.RDN">Constraint for directoryName from name</param>
									/// <param name="any" type="Boolean">Boolean flag - should be comparision interrupted after first match or we need to match all "constraints" parts</param>
									/// <returns type="Boolean">Boolean result - valid or invalid the "name" against the "constraint"</returns>

									//region Initial check
									if (name.typesAndValues.length === 0 || constraint.typesAndValues.length === 0) return true;

									if (name.typesAndValues.length < constraint.typesAndValues.length) return false;
									//endregion

									//region Initial variables
									var result = true;
									var nameStart = 0;
									//endregion

									for (var _i17 = 0; _i17 < constraint.typesAndValues.length; _i17++) {
										var localResult = false;

										for (var _j6 = nameStart; _j6 < name.typesAndValues.length; _j6++) {
											localResult = name.typesAndValues[_j6].isEqual(constraint.typesAndValues[_i17]);

											if (name.typesAndValues[_j6].type === constraint.typesAndValues[_i17].type) result = result && localResult;

											if (localResult === true) {
												if (nameStart === 0 || nameStart === _j6) {
													nameStart = _j6 + 1;
													break;
												} else // Structure of "name" must be the same with "constraint"
													return false;
											}
										}

										if (localResult === false) return false;
									}

									return nameStart === 0 ? false : result;
								};

								//endregion

								//region Check a result from "policy checking" part


								if (!(this.certs.length === 0)) {
									_context8.next = 8;
									break;
								}

								throw "Empty certificate array";

							case 8:
								//endregion

								//region Get input variables
								initialPolicySet = [];

								initialPolicySet.push("2.5.29.32.0"); // "anyPolicy"

								initialExplicitPolicy = false;
								initialPolicyMappingInhibit = false;
								initialInhibitPolicy = false;
								initialPermittedSubtreesSet = []; // Array of "simpl.x509.GeneralSubtree"

								initialExcludedSubtreesSet = []; // Array of "simpl.x509.GeneralSubtree"

								initialRequiredNameForms = []; // Array of "simpl.x509.GeneralSubtree"

								if ("initialPolicySet" in parameters) initialPolicySet = parameters.initialPolicySet;

								if ("initialExplicitPolicy" in parameters) initialExplicitPolicy = parameters.initialExplicitPolicy;

								if ("initialPolicyMappingInhibit" in parameters) initialPolicyMappingInhibit = parameters.initialPolicyMappingInhibit;

								if ("initialInhibitPolicy" in parameters) initialInhibitPolicy = parameters.initialInhibitPolicy;

								if ("initialPermittedSubtreesSet" in parameters) initialPermittedSubtreesSet = parameters.initialPermittedSubtreesSet;

								if ("initialExcludedSubtreesSet" in parameters) initialExcludedSubtreesSet = parameters.initialExcludedSubtreesSet;

								if ("initialRequiredNameForms" in parameters) initialRequiredNameForms = parameters.initialRequiredNameForms;

								explicitPolicyIndicator = initialExplicitPolicy;
								policyMappingInhibitIndicator = initialPolicyMappingInhibit;
								inhibitAnyPolicyIndicator = initialInhibitPolicy;
								pendingConstraints = new Array(3);

								pendingConstraints[0] = false; // For "explicitPolicyPending"
								pendingConstraints[1] = false; // For "policyMappingInhibitPending"
								pendingConstraints[2] = false; // For "inhibitAnyPolicyPending"

								explicitPolicyPending = 0;
								policyMappingInhibitPending = 0;
								inhibitAnyPolicyPending = 0;
								permittedSubtrees = initialPermittedSubtreesSet;
								excludedSubtrees = initialExcludedSubtreesSet;
								requiredNameForms = initialRequiredNameForms;
								pathDepth = 1;
								//endregion

								//region Sorting certificates in the chain array

								_context8.next = 39;
								return this.sort();

							case 39:
								this.certs = _context8.sent;

								//endregion

								//region Work with policies
								//region Support variables
								allPolicies = []; // Array of all policies (string values)

								allPolicies.push("2.5.29.32.0"); // Put "anyPolicy" at first place

								policiesAndCerts = []; // In fact "array of array" where rows are for each specific policy, column for each certificate and value is "true/false"

								anyPolicyArray = new Array(this.certs.length - 1); // Minus "trusted anchor"

								for (ii = 0; ii < this.certs.length - 1; ii++) {
									anyPolicyArray[ii] = true;
								}policiesAndCerts.push(anyPolicyArray);

								policyMappings = new Array(this.certs.length - 1); // Array of "PolicyMappings" for each certificate

								certPolicies = new Array(this.certs.length - 1); // Array of "CertificatePolicies" for each certificate

								explicitPolicyStart = explicitPolicyIndicator ? this.certs.length - 1 : -1;
								//endregion

								//region Gather all neccessary information from certificate chain

								i = this.certs.length - 2;

							case 50:
								if (!(i >= 0)) {
									_context8.next = 105;
									break;
								}

								if (!("extensions" in this.certs[i])) {
									_context8.next = 102;
									break;
								}

								j = 0;

							case 53:
								if (!(j < this.certs[i].extensions.length)) {
									_context8.next = 88;
									break;
								}

								if (!(this.certs[i].extensions[j].extnID === "2.5.29.32")) {
									_context8.next = 79;
									break;
								}

								certPolicies[i] = this.certs[i].extensions[j].parsedValue;

								//region Remove entry from "anyPolicies" for the certificate
								s = 0;

							case 57:
								if (!(s < allPolicies.length)) {
									_context8.next = 64;
									break;
								}

								if (!(allPolicies[s] === "2.5.29.32.0")) {
									_context8.next = 61;
									break;
								}

								delete policiesAndCerts[s][i];
								return _context8.abrupt("break", 64);

							case 61:
								s++;
								_context8.next = 57;
								break;

							case 64:
								k = 0;

							case 65:
								if (!(k < this.certs[i].extensions[j].parsedValue.certificatePolicies.length)) {
									_context8.next = 79;
									break;
								}

								policyIndex = -1;

								//region Try to find extension in "allPolicies" array

								_s = 0;

							case 68:
								if (!(_s < allPolicies.length)) {
									_context8.next = 75;
									break;
								}

								if (!(this.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier === allPolicies[_s])) {
									_context8.next = 72;
									break;
								}

								policyIndex = _s;
								return _context8.abrupt("break", 75);

							case 72:
								_s++;
								_context8.next = 68;
								break;

							case 75:
								//endregion

								if (policyIndex === -1) {
									allPolicies.push(this.certs[i].extensions[j].parsedValue.certificatePolicies[k].policyIdentifier);

									certArray = new Array(this.certs.length - 1);

									certArray[i] = true;

									policiesAndCerts.push(certArray);
								} else policiesAndCerts[policyIndex][i] = true;

							case 76:
								k++;
								_context8.next = 65;
								break;

							case 79:
								if (!(this.certs[i].extensions[j].extnID === "2.5.29.33")) {
									_context8.next = 83;
									break;
								}

								if (!policyMappingInhibitIndicator) {
									_context8.next = 82;
									break;
								}

								return _context8.abrupt("return", {
									result: false,
									resultCode: 98,
									resultMessage: "Policy mapping prohibited"
								});

							case 82:

								policyMappings[i] = this.certs[i].extensions[j].parsedValue;

							case 83:
								//endregion

								//region PolicyConstraints
								if (this.certs[i].extensions[j].extnID === "2.5.29.36") {
									if (explicitPolicyIndicator === false) {
										//region requireExplicitPolicy
										if (this.certs[i].extensions[j].parsedValue.requireExplicitPolicy === 0) {
											explicitPolicyIndicator = true;
											explicitPolicyStart = i;
										} else {
											if (pendingConstraints[0] === false) {
												pendingConstraints[0] = true;
												explicitPolicyPending = this.certs[i].extensions[j].parsedValue.requireExplicitPolicy;
											} else explicitPolicyPending = explicitPolicyPending > this.certs[i].extensions[j].parsedValue.requireExplicitPolicy ? this.certs[i].extensions[j].parsedValue.requireExplicitPolicy : explicitPolicyPending;
										}
										//endregion

										//region inhibitPolicyMapping
										if (this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping === 0) policyMappingInhibitIndicator = true;else {
											if (pendingConstraints[1] === false) {
												pendingConstraints[1] = true;
												policyMappingInhibitPending = this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1;
											} else policyMappingInhibitPending = policyMappingInhibitPending > this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 ? this.certs[i].extensions[j].parsedValue.inhibitPolicyMapping + 1 : policyMappingInhibitPending;
										}
										//endregion
									}
								}
								//endregion

								//region InhibitAnyPolicy
								if (this.certs[i].extensions[j].extnID === "2.5.29.54") {
									if (inhibitAnyPolicyIndicator === false) {
										if (this.certs[i].extensions[j].parsedValue.valueBlock.valueDec === 0) inhibitAnyPolicyIndicator = true;else {
											if (pendingConstraints[2] === false) {
												pendingConstraints[2] = true;
												inhibitAnyPolicyPending = this.certs[i].extensions[j].parsedValue.valueBlock.valueDec;
											} else inhibitAnyPolicyPending = inhibitAnyPolicyPending > this.certs[i].extensions[j].parsedValue.valueBlock.valueDec ? this.certs[i].extensions[j].parsedValue.valueBlock.valueDec : inhibitAnyPolicyPending;
										}
									}
								}
								//endregion

							case 85:
								j++;
								_context8.next = 53;
								break;

							case 88:
								if (!(inhibitAnyPolicyIndicator === true)) {
									_context8.next = 99;
									break;
								}

								_policyIndex = -1;

								//region Find "anyPolicy" index

								searchAnyPolicy = 0;

							case 91:
								if (!(searchAnyPolicy < allPolicies.length)) {
									_context8.next = 98;
									break;
								}

								if (!(allPolicies[searchAnyPolicy] === "2.5.29.32.0")) {
									_context8.next = 95;
									break;
								}

								_policyIndex = searchAnyPolicy;
								return _context8.abrupt("break", 98);

							case 95:
								searchAnyPolicy++;
								_context8.next = 91;
								break;

							case 98:
								//endregion

								if (_policyIndex !== -1) delete policiesAndCerts[0][i]; // Unset value to "undefined" for "anyPolicies" value for current certificate

							case 99:
								//endregion

								//region Process with "pending constraints"
								if (explicitPolicyIndicator === false) {
									if (pendingConstraints[0] === true) {
										explicitPolicyPending--;
										if (explicitPolicyPending === 0) {
											explicitPolicyIndicator = true;
											explicitPolicyStart = i;

											pendingConstraints[0] = false;
										}
									}
								}

								if (policyMappingInhibitIndicator === false) {
									if (pendingConstraints[1] === true) {
										policyMappingInhibitPending--;
										if (policyMappingInhibitPending === 0) {
											policyMappingInhibitIndicator = true;
											pendingConstraints[1] = false;
										}
									}
								}

								if (inhibitAnyPolicyIndicator === false) {
									if (pendingConstraints[2] === true) {
										inhibitAnyPolicyPending--;
										if (inhibitAnyPolicyPending === 0) {
											inhibitAnyPolicyIndicator = true;
											pendingConstraints[2] = false;
										}
									}
								}
								//endregion

							case 102:
								i--, pathDepth++;
								_context8.next = 50;
								break;

							case 105:
								_i7 = 0;

							case 106:
								if (!(_i7 < this.certs.length - 1)) {
									_context8.next = 123;
									break;
								}

								if (!(_i7 < this.certs.length - 2 && typeof policyMappings[_i7 + 1] !== "undefined")) {
									_context8.next = 120;
									break;
								}

								_k = 0;

							case 109:
								if (!(_k < policyMappings[_i7 + 1].mappings.length)) {
									_context8.next = 120;
									break;
								}

								if (!(policyMappings[_i7 + 1].mappings[_k].issuerDomainPolicy === "2.5.29.32.0" || policyMappings[_i7 + 1].mappings[_k].subjectDomainPolicy === "2.5.29.32.0")) {
									_context8.next = 112;
									break;
								}

								return _context8.abrupt("return", {
									result: false,
									resultCode: 99,
									resultMessage: "The \"anyPolicy\" should not be a part of policy mapping scheme"
								});

							case 112:
								//endregion

								//region Initial variables
								issuerDomainPolicyIndex = -1;
								subjectDomainPolicyIndex = -1;
								//endregion

								//region Search for index of policies indedes

								for (n = 0; n < allPolicies.length; n++) {
									if (allPolicies[n] === policyMappings[_i7 + 1].mappings[_k].issuerDomainPolicy) issuerDomainPolicyIndex = n;

									if (allPolicies[n] === policyMappings[_i7 + 1].mappings[_k].subjectDomainPolicy) subjectDomainPolicyIndex = n;
								}
								//endregion

								//region Delete existing "issuerDomainPolicy" because on the level we mapped the policy to another one
								if (typeof policiesAndCerts[issuerDomainPolicyIndex][_i7] !== "undefined") delete policiesAndCerts[issuerDomainPolicyIndex][_i7];
								//endregion

								//region Check all policies for the certificate
								for (_j2 = 0; _j2 < certPolicies[_i7].certificatePolicies.length; _j2++) {
									if (policyMappings[_i7 + 1].mappings[_k].subjectDomainPolicy === certPolicies[_i7].certificatePolicies[_j2].policyIdentifier) {
										//region Set mapped policy for current certificate
										if (issuerDomainPolicyIndex !== -1 && subjectDomainPolicyIndex !== -1) {
											for (m = 0; m <= _i7; m++) {
												if (typeof policiesAndCerts[subjectDomainPolicyIndex][m] !== "undefined") {
													policiesAndCerts[issuerDomainPolicyIndex][m] = true;
													delete policiesAndCerts[subjectDomainPolicyIndex][m];
												}
											}
										}
										//endregion
									}
								}
								//endregion

							case 117:
								_k++;
								_context8.next = 109;
								break;

							case 120:
								_i7++;
								_context8.next = 106;
								break;

							case 123:
								//endregion

								//region Working with "explicitPolicyIndicator" and "anyPolicy"
								for (_i8 = 0; _i8 < allPolicies.length; _i8++) {
									if (allPolicies[_i8] === "2.5.29.32.0") {
										for (_j3 = 0; _j3 < explicitPolicyStart; _j3++) {
											delete policiesAndCerts[_i8][_j3];
										}
									}
								}
								//endregion

								//region Create "set of authorities-constrained policies"
								authConstrPolicies = [];
								_i9 = 0;

							case 126:
								if (!(_i9 < policiesAndCerts.length)) {
									_context8.next = 154;
									break;
								}

								found = true;
								_j4 = 0;

							case 129:
								if (!(_j4 < this.certs.length - 1)) {
									_context8.next = 150;
									break;
								}

								anyPolicyFound = false;

								if (!(_j4 < explicitPolicyStart && allPolicies[_i9] === "2.5.29.32.0" && allPolicies.length > 1)) {
									_context8.next = 134;
									break;
								}

								found = false;
								return _context8.abrupt("break", 150);

							case 134:
								if (!(typeof policiesAndCerts[_i9][_j4] === "undefined")) {
									_context8.next = 147;
									break;
								}

								if (!(_j4 >= explicitPolicyStart)) {
									_context8.next = 144;
									break;
								}

								_k2 = 0;

							case 137:
								if (!(_k2 < allPolicies.length)) {
									_context8.next = 144;
									break;
								}

								if (!(allPolicies[_k2] === "2.5.29.32.0")) {
									_context8.next = 141;
									break;
								}

								if (policiesAndCerts[_k2][_j4] === true) anyPolicyFound = true;

								return _context8.abrupt("break", 144);

							case 141:
								_k2++;
								_context8.next = 137;
								break;

							case 144:
								if (anyPolicyFound) {
									_context8.next = 147;
									break;
								}

								found = false;
								return _context8.abrupt("break", 150);

							case 147:
								_j4++;
								_context8.next = 129;
								break;

							case 150:

								if (found === true) authConstrPolicies.push(allPolicies[_i9]);

							case 151:
								_i9++;
								_context8.next = 126;
								break;

							case 154:
								//endregion

								//region Create "set of user-constrained policies"
								userConstrPolicies = [];

								if (!(initialPolicySet.length === 1 && initialPolicySet[0] === "2.5.29.32.0" && explicitPolicyIndicator === false)) {
									_context8.next = 159;
									break;
								}

								userConstrPolicies = initialPolicySet;
								_context8.next = 176;
								break;

							case 159:
								if (!(authConstrPolicies.length === 1 && authConstrPolicies[0] === "2.5.29.32.0")) {
									_context8.next = 163;
									break;
								}

								userConstrPolicies = initialPolicySet;
								_context8.next = 176;
								break;

							case 163:
								_i10 = 0;

							case 164:
								if (!(_i10 < authConstrPolicies.length)) {
									_context8.next = 176;
									break;
								}

								_j5 = 0;

							case 166:
								if (!(_j5 < initialPolicySet.length)) {
									_context8.next = 173;
									break;
								}

								if (!(initialPolicySet[_j5] === authConstrPolicies[_i10] || initialPolicySet[_j5] === "2.5.29.32.0")) {
									_context8.next = 170;
									break;
								}

								userConstrPolicies.push(authConstrPolicies[_i10]);
								return _context8.abrupt("break", 173);

							case 170:
								_j5++;
								_context8.next = 166;
								break;

							case 173:
								_i10++;
								_context8.next = 164;
								break;

							case 176:
								//endregion

								//region Combine output object
								policyResult = {
									result: userConstrPolicies.length > 0,
									resultCode: 0,
									resultMessage: userConstrPolicies.length > 0 ? "" : "Zero \"userConstrPolicies\" array, no intersections with \"authConstrPolicies\"",
									authConstrPolicies: authConstrPolicies,
									userConstrPolicies: userConstrPolicies,
									explicitPolicyIndicator: explicitPolicyIndicator,
									policyMappings: policyMappings,
									certificatePath: this.certs
								};

								if (!(userConstrPolicies.length === 0)) {
									_context8.next = 179;
									break;
								}

								return _context8.abrupt("return", policyResult);

							case 179:
								if (!(policyResult.result === false)) {
									_context8.next = 181;
									break;
								}

								return _context8.abrupt("return", policyResult);

							case 181:
								//endregion

								//region Check all certificates, excluding "trust anchor"
								pathDepth = 1;

								_i18 = this.certs.length - 2;

							case 183:
								if (!(_i18 >= 0)) {
									_context8.next = 305;
									break;
								}

								//region Support variables
								subjectAltNames = [];
								certPermittedSubtrees = [];
								certExcludedSubtrees = [];
								//endregion

								if ("extensions" in this.certs[_i18]) {
									for (_j7 = 0; _j7 < this.certs[_i18].extensions.length; _j7++) {
										//region NameConstraints
										if (this.certs[_i18].extensions[_j7].extnID === "2.5.29.30") {
											if ("permittedSubtrees" in this.certs[_i18].extensions[_j7].parsedValue) certPermittedSubtrees = certPermittedSubtrees.concat(this.certs[_i18].extensions[_j7].parsedValue.permittedSubtrees);

											if ("excludedSubtrees" in this.certs[_i18].extensions[_j7].parsedValue) certExcludedSubtrees = certExcludedSubtrees.concat(this.certs[_i18].extensions[_j7].parsedValue.excludedSubtrees);
										}
										//endregion

										//region SubjectAltName
										if (this.certs[_i18].extensions[_j7].extnID === "2.5.29.17") subjectAltNames = subjectAltNames.concat(this.certs[_i18].extensions[_j7].parsedValue.altNames);
										//endregion
									}
								}

								//region Checking for "required name forms"
								formFound = requiredNameForms.length <= 0;
								_j8 = 0;

							case 190:
								if (!(_j8 < requiredNameForms.length)) {
									_context8.next = 211;
									break;
								}

								_context8.t0 = requiredNameForms[_j8].base.type;
								_context8.next = _context8.t0 === 4 ? 194 : 208;
								break;

							case 194:
								if (!(requiredNameForms[_j8].base.value.typesAndValues.length !== this.certs[_i18].subject.typesAndValues.length)) {
									_context8.next = 196;
									break;
								}

								return _context8.abrupt("continue", 208);

							case 196:

								formFound = true;

								_k3 = 0;

							case 198:
								if (!(_k3 < this.certs[_i18].subject.typesAndValues.length)) {
									_context8.next = 205;
									break;
								}

								if (!(this.certs[_i18].subject.typesAndValues[_k3].type !== requiredNameForms[_j8].base.value.typesAndValues[_k3].type)) {
									_context8.next = 202;
									break;
								}

								formFound = false;
								return _context8.abrupt("break", 205);

							case 202:
								_k3++;
								_context8.next = 198;
								break;

							case 205:
								if (!(formFound === true)) {
									_context8.next = 207;
									break;
								}

								return _context8.abrupt("break", 208);

							case 207:
								return _context8.abrupt("break", 208);

							case 208:
								_j8++;
								_context8.next = 190;
								break;

							case 211:
								if (!(formFound === false)) {
									_context8.next = 216;
									break;
								}

								policyResult.result = false;
								policyResult.resultCode = 21;
								policyResult.resultMessage = "No neccessary name form found";

								throw policyResult;

							case 216:
								//endregion

								//region Checking for "permited sub-trees"
								//region Make groups for all types of constraints
								constrGroups = []; // Array of array for groupped constraints

								constrGroups[0] = []; // rfc822Name
								constrGroups[1] = []; // dNSName
								constrGroups[2] = []; // directoryName
								constrGroups[3] = []; // uniformResourceIdentifier
								constrGroups[4] = []; // iPAddress

								_j9 = 0;

							case 223:
								if (!(_j9 < permittedSubtrees.length)) {
									_context8.next = 240;
									break;
								}

								_context8.t1 = permittedSubtrees[_j9].base.type;
								_context8.next = _context8.t1 === 1 ? 227 : _context8.t1 === 2 ? 229 : _context8.t1 === 4 ? 231 : _context8.t1 === 6 ? 233 : _context8.t1 === 7 ? 235 : 237;
								break;

							case 227:
								constrGroups[0].push(permittedSubtrees[_j9]);
								return _context8.abrupt("break", 237);

							case 229:
								constrGroups[1].push(permittedSubtrees[_j9]);
								return _context8.abrupt("break", 237);

							case 231:
								constrGroups[2].push(permittedSubtrees[_j9]);
								return _context8.abrupt("break", 237);

							case 233:
								constrGroups[3].push(permittedSubtrees[_j9]);
								return _context8.abrupt("break", 237);

							case 235:
								constrGroups[4].push(permittedSubtrees[_j9]);
								return _context8.abrupt("break", 237);

							case 237:
								_j9++;
								_context8.next = 223;
								break;

							case 240:
								p = 0;

							case 241:
								if (!(p < 5)) {
									_context8.next = 274;
									break;
								}

								groupPermitted = false;
								valueExists = false;
								group = constrGroups[p];
								_j10 = 0;

							case 246:
								if (!(_j10 < group.length)) {
									_context8.next = 266;
									break;
								}

								_context8.t2 = p;
								_context8.next = _context8.t2 === 0 ? 250 : _context8.t2 === 1 ? 252 : _context8.t2 === 2 ? 254 : _context8.t2 === 3 ? 257 : _context8.t2 === 4 ? 259 : 261;
								break;

							case 250:
								if (subjectAltNames.length > 0) {
									for (_k4 = 0; _k4 < subjectAltNames.length; _k4++) {
										if (subjectAltNames[_k4].type === 1) // rfc822Name
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareRFC822Name(subjectAltNames[_k4].value, group[_j10].base.value);
											}
									}
								} else // Try to find out "emailAddress" inside "subject"
									{
										for (_k5 = 0; _k5 < this.certs[_i18].subject.typesAndValues.length; _k5++) {
											if (this.certs[_i18].subject.typesAndValues[_k5].type === "1.2.840.113549.1.9.1" || // PKCS#9 e-mail address
											this.certs[_i18].subject.typesAndValues[_k5].type === "0.9.2342.19200300.100.1.3") // RFC1274 "rfc822Mailbox" e-mail address
												{
													valueExists = true;
													groupPermitted = groupPermitted || compareRFC822Name(this.certs[_i18].subject.typesAndValues[_k5].value.valueBlock.value, group[_j10].base.value);
												}
										}
									}
								return _context8.abrupt("break", 261);

							case 252:
								if (subjectAltNames.length > 0) {
									for (_k6 = 0; _k6 < subjectAltNames.length; _k6++) {
										if (subjectAltNames[_k6].type === 2) // dNSName
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareDNSName(subjectAltNames[_k6].value, group[_j10].base.value);
											}
									}
								}
								return _context8.abrupt("break", 261);

							case 254:
								valueExists = true;
								groupPermitted = compareDirectoryName(this.certs[_i18].subject, group[_j10].base.value);
								return _context8.abrupt("break", 261);

							case 257:
								if (subjectAltNames.length > 0) {
									for (_k7 = 0; _k7 < subjectAltNames.length; _k7++) {
										if (subjectAltNames[_k7].type === 6) // uniformResourceIdentifier
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareUniformResourceIdentifier(subjectAltNames[_k7].value, group[_j10].base.value);
											}
									}
								}
								return _context8.abrupt("break", 261);

							case 259:
								if (subjectAltNames.length > 0) {
									for (_k8 = 0; _k8 < subjectAltNames.length; _k8++) {
										if (subjectAltNames[_k8].type === 7) // iPAddress
											{
												valueExists = true;
												groupPermitted = groupPermitted || compareIPAddress(subjectAltNames[_k8].value, group[_j10].base.value);
											}
									}
								}
								return _context8.abrupt("break", 261);

							case 261:
								if (!groupPermitted) {
									_context8.next = 263;
									break;
								}

								return _context8.abrupt("break", 266);

							case 263:
								_j10++;
								_context8.next = 246;
								break;

							case 266:
								if (!(groupPermitted === false && group.length > 0 && valueExists)) {
									_context8.next = 271;
									break;
								}

								policyResult.result = false;
								policyResult.resultCode = 41;
								policyResult.resultMessage = "Failed to meet \"permitted sub-trees\" name constraint";

								throw policyResult;

							case 271:
								p++;
								_context8.next = 241;
								break;

							case 274:
								//endregion
								//endregion

								//region Checking for "excluded sub-trees"
								excluded = false;
								_j11 = 0;

							case 276:
								if (!(_j11 < excludedSubtrees.length)) {
									_context8.next = 295;
									break;
								}

								_context8.t3 = excludedSubtrees[_j11].base.type;
								_context8.next = _context8.t3 === 1 ? 280 : _context8.t3 === 2 ? 282 : _context8.t3 === 4 ? 284 : _context8.t3 === 6 ? 286 : _context8.t3 === 7 ? 288 : 290;
								break;

							case 280:
								if (subjectAltNames.length >= 0) {
									for (_k9 = 0; _k9 < subjectAltNames.length; _k9++) {
										if (subjectAltNames[_k9].type === 1) // rfc822Name
											excluded = excluded || compareRFC822Name(subjectAltNames[_k9].value, excludedSubtrees[_j11].base.value);
									}
								} else // Try to find out "emailAddress" inside "subject"
									{
										for (_k10 = 0; _k10 < this.subject.typesAndValues.length; _k10++) {
											if (this.subject.typesAndValues[_k10].type === "1.2.840.113549.1.9.1" || // PKCS#9 e-mail address
											this.subject.typesAndValues[_k10].type === "0.9.2342.19200300.100.1.3") // RFC1274 "rfc822Mailbox" e-mail address
												excluded = excluded || compareRFC822Name(this.subject.typesAndValues[_k10].value.valueBlock.value, excludedSubtrees[_j11].base.value);
										}
									}
								return _context8.abrupt("break", 290);

							case 282:
								if (subjectAltNames.length > 0) {
									for (_k11 = 0; _k11 < subjectAltNames.length; _k11++) {
										if (subjectAltNames[_k11].type === 2) // dNSName
											excluded = excluded || compareDNSName(subjectAltNames[_k11].value, excludedSubtrees[_j11].base.value);
									}
								}
								return _context8.abrupt("break", 290);

							case 284:
								excluded = excluded || compareDirectoryName(this.certs[_i18].subject, excludedSubtrees[_j11].base.value);
								return _context8.abrupt("break", 290);

							case 286:
								if (subjectAltNames.length > 0) {
									for (_k12 = 0; _k12 < subjectAltNames.length; _k12++) {
										if (subjectAltNames[_k12].type === 6) // uniformResourceIdentifier
											excluded = excluded || compareUniformResourceIdentifier(subjectAltNames[_k12].value, excludedSubtrees[_j11].base.value);
									}
								}
								return _context8.abrupt("break", 290);

							case 288:
								if (subjectAltNames.length > 0) {
									for (_k13 = 0; _k13 < subjectAltNames.length; _k13++) {
										if (subjectAltNames[_k13].type === 7) // iPAddress
											excluded = excluded || compareIPAddress(subjectAltNames[_k13].value, excludedSubtrees[_j11].base.value);
									}
								}
								return _context8.abrupt("break", 290);

							case 290:
								if (!excluded) {
									_context8.next = 292;
									break;
								}

								return _context8.abrupt("break", 295);

							case 292:
								_j11++;
								_context8.next = 276;
								break;

							case 295:
								if (!(excluded === true)) {
									_context8.next = 300;
									break;
								}

								policyResult.result = false;
								policyResult.resultCode = 42;
								policyResult.resultMessage = "Failed to meet \"excluded sub-trees\" name constraint";

								throw policyResult;

							case 300:
								//endregion

								//region Append "cert_..._subtrees" to "..._subtrees"
								permittedSubtrees = permittedSubtrees.concat(certPermittedSubtrees);
								excludedSubtrees = excludedSubtrees.concat(certExcludedSubtrees);
								//endregion

							case 302:
								_i18--, pathDepth++;
								_context8.next = 183;
								break;

							case 305:
								return _context8.abrupt("return", policyResult);

							case 308:
								_context8.prev = 308;
								_context8.t4 = _context8["catch"](0);

								if (!(_context8.t4 instanceof Object)) {
									_context8.next = 315;
									break;
								}

								if (!("resultMessage" in _context8.t4)) {
									_context8.next = 313;
									break;
								}

								return _context8.abrupt("return", _context8.t4);

							case 313:
								if (!("message" in _context8.t4)) {
									_context8.next = 315;
									break;
								}

								return _context8.abrupt("return", {
									result: false,
									resultCode: -1,
									resultMessage: _context8.t4.message
								});

							case 315:
								return _context8.abrupt("return", {
									result: false,
									resultCode: -1,
									resultMessage: _context8.t4
								});

							case 316:
							case "end":
								return _context8.stop();
						}
					}
				}, _callee8, this, [[0, 308]]);
			}));

			function verify() {
				return _ref8.apply(this, arguments);
			}

			return verify;
		}()
		//**********************************************************************************

	}]);

	return CertificateChainValidationEngine;
}();
//**************************************************************************************


exports.default = CertificateChainValidationEngine;
//# sourceMappingURL=CertificateChainValidationEngine.js.map